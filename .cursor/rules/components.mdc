---
alwaysApply: false
description: This file describes what is, and how to use components in deco framework.
---

# Components in Deco Framework

> **Note:** For SSR patterns and Islands architecture, see the [SSR Patterns guide](ssr.mdc) and [Islands guide](islands.mdc).

## Component Structure

- Organize components in folders by functionality or type.
- Keep components small and focused on a single responsibility.
- Break down complex interfaces into reusable subcomponents.
- Use TypeScript for props and function returns.

## Props and Interfaces

- Define all props in an interface named `Props`.
- Document complex props with comments.
- Provide default values for optional props.
- Use specific types instead of generic ones (e.g., `string[]` instead of `any[]`).
- Prefer interfaces for configuration objects and types for union types.

## Reusability and Consistency

- Extract shared logic to utilities and helper functions.
- Maintain consistent naming patterns throughout the project.
- Use the same export style across all components (default export for sections).
- Keep event handlers and callback functions with clear and consistent names.
- Use Fresh Islands for client-side interactivity.

## Accessibility and Semantics

- Use appropriate semantic HTML markup (e.g., `button` for buttons, `nav` for navigation).
- Include `aria-*` and `role` attributes when necessary.
- Ensure components are keyboard accessible.

## Conditional Rendering

- Use ternary operators for simple conditional rendering.
- For more complex logic, extract to variables or helper functions.
- Avoid excessive nesting of conditionals.
- Use early return to simplify logic when appropriate.

## State and Effects

- **Sections/Components are SSR**: Server-side rendered, no client-side hooks
- **Islands have client-side state**: Use Preact hooks (useState, useEffect, useSignal) in Islands
- **For interactivity**: Create Islands in `islands/` directory
- **State management**: Use signals for global state, useState for local state

## Performance

- Avoid using external libs when possible
- Use Fresh Islands for Sliders, Drags, and other UX features
- Keep Islands small and focused for optimal performance
- Process data server-side when possible (loaders, useDevice)


### useId Utility

The `useId` utility helps generate unique IDs for components to avoid conflicts:

```tsx
import { useId } from "../../sdk/useId.ts";
```

**Why use useId?**

- As of July 2023, Fresh has a bug where Preact's `useId` returns the same ID for different islands
- This creates duplicate IDs in the final markup, causing accessibility and functionality issues
- `useId` uses a non-deterministic approach to prevent duplicate IDs

**Usage:**

```tsx
export default function MyComponent() {
  const id = useId(); // Generates unique ID like "button-123456"

  return <button id={`button-${id}`}>Click me</button>;
}
```

**Note:** The non-deterministic approach may cause hydration mismatches, but it's necessary to prevent duplicate IDs in SSR components.

## Component Example (SSR Component)

Simple presentational components remain server-side:

```tsx
import Icon from "../ui/Icon.tsx";
import { clx } from "../../sdk/clx.ts";

export interface ButtonProps {
  /**
   * Text to display inside the button
   */
  text: string;
  /**
   * Optional icon to display alongside text
   */
  icon?: string;
  /**
   * Button variant
   */
  variant?: "primary" | "secondary" | "outline";
  /**
   * Button size
   */
  size?: "small" | "medium" | "large";
  /**
   * Link href (if button should be a link)
   */
  href?: string;
}

export default function Button({
  text,
  icon,
  variant = "primary",
  size = "medium",
  href,
}: ButtonProps) {
  const className = clx(
    "btn transition-all",
    variant === "primary"
      ? "btn-primary"
      : variant === "secondary"
      ? "btn-secondary"
      : "btn-outline",
    size === "small" ? "btn-sm" : size === "large" ? "btn-lg" : ""
  );

  if (href) {
    return (
      <a href={href} class={className}>
        {icon && <Icon id={icon} class="mr-2" />}
        {text}
      </a>
    );
  }

  return (
    <button class={className}>
      {icon && <Icon id={icon} class="mr-2" />}
      {text}
    </button>
  );
}
```

## Interactive Component Example (Island)

For interactive components, create Islands:

```tsx
// islands/ui/AnimatedButton.tsx
import { useState } from "preact/hooks";
import Icon from "../../components/ui/Icon.tsx";
import { clx } from "../../sdk/clx.ts";

interface Props {
  text: string;
  icon?: string;
  variant?: "primary" | "secondary" | "outline";
  disabled?: boolean;
  onClick?: () => void;
}

export default function AnimatedButton({
  text,
  icon,
  variant = "primary",
  disabled = false,
  onClick,
}: Props) {
  const [isAnimating, setIsAnimating] = useState(false);

  const handleClick = () => {
    if (disabled || isAnimating) return;
    
    setIsAnimating(true);
    setTimeout(() => setIsAnimating(false), 200);
    
    onClick?.();
  };

  return (
    <button
      onClick={handleClick}
      disabled={disabled}
      class={clx(
        "btn transition-all",
        variant === "primary" ? "btn-primary" 
          : variant === "secondary" ? "btn-secondary" 
          : "btn-outline",
        isAnimating && "animate-pulse",
        disabled && "btn-disabled"
      )}
    >
      {icon && <Icon id={icon} class="mr-2" />}
      {text}
    </button>
  );
}
```

## Common Component Patterns

### Loading States (Island)

```tsx
// islands/data/DataLoader.tsx
import { useEffect, useState } from "preact/hooks";

interface Props {
  endpoint: string;
}

export default function DataLoader({ endpoint }: Props) {
  const [loading, setLoading] = useState(true);
  const [data, setData] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetch(endpoint)
      .then((res) => res.json())
      .then((result) => {
        setData(result);
        setLoading(false);
      })
      .catch((err) => {
        setError(err.message);
        setLoading(false);
      });
  }, [endpoint]);

  if (loading) {
    return <div class="animate-pulse">Loading...</div>;
  }

  if (error) {
    return <div class="text-red-500">Error: {error}</div>;
  }

  return <div>{data}</div>;
}
```

### Form Components (Island)

```tsx
// islands/forms/FormField.tsx
import { useState } from "preact/hooks";
import { clx } from "../../sdk/clx.ts";

interface Props {
  label: string;
  name: string;
  type?: "text" | "email" | "password" | "number";
  required?: boolean;
  placeholder?: string;
  value?: string;
  onChange?: (value: string) => void;
}

export default function FormField({
  label,
  name,
  type = "text",
  required = false,
  placeholder,
  value = "",
  onChange,
}: Props) {
  const [error, setError] = useState("");
  const [localValue, setLocalValue] = useState(value);

  const validate = (val: string) => {
    if (required && !val.trim()) {
      setError(`${label} is required`);
      return false;
    }
    
    if (type === "email" && !val.includes("@")) {
      setError("Invalid email");
      return false;
    }
    
    setError("");
    return true;
  };

  const handleChange = (e: Event) => {
    const newValue = (e.currentTarget as HTMLInputElement).value;
    setLocalValue(newValue);
    onChange?.(newValue);
  };

  const handleBlur = () => {
    validate(localValue);
  };

  return (
    <div class="form-field mb-4">
      <label
        htmlFor={name}
        class={clx(
          "block text-sm font-medium mb-1",
          error ? "text-red-700" : "text-gray-700"
        )}
      >
        {label}
        {required && <span class="text-red-500 ml-1">*</span>}
      </label>

      <input
        id={name}
        name={name}
        type={type}
        value={localValue}
        placeholder={placeholder}
        required={required}
        onChange={handleChange}
        onBlur={handleBlur}
        class={clx(
          "w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2",
          error
            ? "border-red-300 focus:ring-red-500"
            : "border-gray-300 focus:ring-blue-500"
        )}
        aria-invalid={!!error}
      />

      {error && (
        <p class="text-red-600 text-sm mt-1">{error}</p>
      )}
    </div>
  );
}
```

## Best Practices Summary

### ✅ Do

- Use semantic HTML elements
- Implement proper TypeScript interfaces
- **Use Islands for client-side interactivity**
- Handle loading and error states properly
- Add accessibility attributes
- Keep components focused and small
- Use consistent naming conventions
- Document complex props with JSDoc
- Use `useId` utility for generating unique IDs
- Follow SSR + Islands patterns (see `ssr.mdc` and `islands.mdc`)

### ❌ Don't

- **Don't use Preact hooks in SSR components** (only in Islands)
- Don't mutate props directly
- Don't create deeply nested component hierarchies
- Don't ignore accessibility requirements
- Don't use `any` type extensively
- Don't create monolithic components
- Don't forget to handle edge cases
- **Don't use useScript for new code** (use Islands instead)
- Don't forget cleanup in Island useEffect hooks


### Component Organization
```

/components
/ui
Button.tsx
Input.tsx
Modal.tsx
/layout
Header.tsx
Footer.tsx
Sidebar.tsx
/product
ProductCard.tsx
ProductGrid.tsx
ProductDetails.tsx

```

```
