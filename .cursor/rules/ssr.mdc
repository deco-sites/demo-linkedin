---
alwaysApply: false
description: This file describes SSR patterns and script injection in Deco Framework.
---

# SSR Patterns in Deco Framework

## Server-Side Rendering (SSR)

Deco Framework uses server-side rendering for all components. This means:

- All sections/components are rendered on the server
- Use **Fresh Islands** for client-side interactivity
- Islands allow **selective hydration** - only interactive parts run on the client
- Better performance with smaller JavaScript bundles

## Client-Side Interactivity

### Use Islands for Interactivity

**DO:** Use Islands for client-side functionality
```tsx
// islands/counter/CounterButton.tsx
import { useSignal } from "@preact/signals";

export default function CounterButton() {
  const count = useSignal(0);

  return (
    <div class="flex items-center gap-4">
      <button onClick={() => count.value--} class="btn">-</button>
      <span>{count.value}</span>
      <button onClick={() => count.value++} class="btn">+</button>
    </div>
  );
}
```

```tsx
// sections/Interactive/Counter.tsx
import CounterButton from "../../islands/counter/CounterButton.tsx";

export default function Counter() {
  return (
    <div class="container mx-auto p-8">
      <h2 class="text-2xl mb-4">Counter</h2>
      <CounterButton />
    </div>
  );
}
```

### Legacy Pattern (useScript) - Avoid for New Code

**DON'T:** Use `useScript` for new code (legacy pattern)

```tsx
// ❌ Legacy approach - avoid in new code
import { useScript } from "@deco/deco/hooks";

function myScript(name: string) {
  console.log("hello", name);
}

export default function MyComponent() {
  return (
    <script
      type="module"
      dangerouslySetInnerHTML={{
        __html: useScript(myScript, "lucas"),
      }}
    />
  );
}
```

## State Management Patterns

### 1. Local Component State (Islands)

```tsx
// islands/ui/Toggle.tsx
import { useState } from "preact/hooks";

export default function Toggle() {
  const [isActive, setIsActive] = useState(false);

  return (
    <button 
      onClick={() => setIsActive(!isActive)}
      class={isActive ? "btn-active" : "btn"}
    >
      {isActive ? "Active" : "Inactive"}
    </button>
  );
}
```

### 2. Global State with Signals

```tsx
// sdk/context.ts
import { signal } from "@preact/signals";

export const state = {
  user: signal<User | null>(null),
  cart: signal<Cart | undefined>(undefined),
};
```

```tsx
// islands/header/UserButton.tsx
import { useEffect, useState } from "preact/hooks";
import { state } from "../../sdk/context.ts";

export default function UserButton() {
  const [user, setUser] = useState(state.user.value);

  useEffect(() => {
    return state.user.subscribe((newUser) => {
      setUser(newUser);
    });
  }, []);

  return (
    <button class="btn">
      {user ? `Hi, ${user.name}` : "Sign In"}
    </button>
  );
}
```

### 3. Effect-Based Interactivity

```tsx
// islands/ui/Accordion.tsx
import { useEffect, useState } from "preact/hooks";
import { useId } from "../../sdk/hooks/useId.ts";

interface Props {
  title: string;
  content: string;
}

export default function Accordion({ title, content }: Props) {
  const [isExpanded, setIsExpanded] = useState(false);
  const id = useId();

  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      if (e.key === "Escape") {
        setIsExpanded(false);
      }
    };

    if (isExpanded) {
      addEventListener("keydown", handler);
      return () => removeEventListener("keydown", handler);
    }
  }, [isExpanded]);

  return (
    <div class="accordion">
      <button
        id={id}
        onClick={() => setIsExpanded(!isExpanded)}
        class="accordion-header btn"
        aria-expanded={isExpanded}
      >
        {title}
      </button>
      
      {isExpanded && (
        <div id={`${id}-content`} class="accordion-content p-4">
          {content}
        </div>
      )}
    </div>
  );
}
```

## Common SSR + Island Patterns

### 1. Server Processes Data, Island Adds Interactivity

```tsx
// sections/Images/ImageCarousel.tsx
import { useDevice } from "@deco/deco/hooks";
import ImageCarouselIsland from "../../islands/images/ImageCarousel.tsx";

interface Item {
  desktopImage: ImageWidget;
  mobileImage: ImageWidget;
  desktopWidth: number;
  desktopHeight: number;
  mobileWidth: number;
  mobileHeight: number;
}

interface Props {
  images: Item[];
}

export default function ImageCarousel({ images }: Props) {
  const device = useDevice(); // Server-side only!
  const isMobile = device === "mobile";

  // Process images server-side
  const processedImages = images.map((img) => ({
    src: isMobile ? img.mobileImage : img.desktopImage,
    width: isMobile ? img.mobileWidth : img.desktopWidth,
    height: isMobile ? img.mobileHeight : img.desktopHeight,
  }));

  // Pass to island for interactivity
  return <ImageCarouselIsland images={processedImages} />;
}
```

```tsx
// islands/images/ImageCarousel.tsx
import { useEffect } from "preact/hooks";
import { useId } from "../../sdk/hooks/useId.ts";
import Image from "apps/website/components/Image.tsx";

interface CarouselImage {
  src: string;
  width: number;
  height: number;
}

interface Props {
  images: CarouselImage[];
}

export default function ImageCarousel({ images }: Props) {
  const id = useId();

  useEffect(() => {
    const container = document.getElementById(id);
    if (!container) return;

    let isDragging = false;
    let startX = 0;
    let scrollLeft = 0;

    const handleMouseDown = (e: MouseEvent) => {
      isDragging = true;
      startX = e.pageX;
      scrollLeft = container.scrollLeft;
    };

    const handleMouseMove = (e: MouseEvent) => {
      if (!isDragging) return;
      const walk = (e.pageX - startX) * 2;
      container.scrollLeft = scrollLeft - walk;
    };

    const handleMouseUp = () => {
      isDragging = false;
    };

    container.addEventListener("mousedown", handleMouseDown);
    container.addEventListener("mousemove", handleMouseMove);
    container.addEventListener("mouseup", handleMouseUp);

    return () => {
      container.removeEventListener("mousedown", handleMouseDown);
      container.removeEventListener("mousemove", handleMouseMove);
      container.removeEventListener("mouseup", handleMouseUp);
    };
  }, [id]);

  return (
    <div id={id} class="overflow-x-auto cursor-grab">
      <div class="inline-flex gap-4">
        {images.map((img, i) => (
          <Image
            key={i}
            src={img.src}
            width={img.width}
            height={img.height}
            class="rounded-lg"
          />
        ))}
      </div>
    </div>
  );
}
```

### 2. Form with Client-Side Validation

```tsx
// islands/forms/ContactForm.tsx
import { useState } from "preact/hooks";

export default function ContactForm() {
  const [email, setEmail] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  const validateEmail = (value: string) => {
    if (!value.includes("@")) {
      setError("Invalid email");
      return false;
    }
    setError("");
    return true;
  };

  const handleSubmit = async (e: Event) => {
    e.preventDefault();
    
    if (!validateEmail(email)) return;
    
    setLoading(true);
    try {
      await fetch("/api/contact", {
        method: "POST",
        body: JSON.stringify({ email }),
      });
      alert("Success!");
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} class="space-y-4">
      <div>
        <input
          type="email"
          value={email}
          onChange={(e) => {
            setEmail(e.currentTarget.value);
            validateEmail(e.currentTarget.value);
          }}
          onBlur={() => validateEmail(email)}
          class="input input-bordered w-full"
          required
        />
        {error && <p class="text-red-500 text-sm mt-1">{error}</p>}
      </div>
      
      <button 
        type="submit" 
        disabled={loading || !!error}
        class="btn btn-primary"
      >
        {loading ? "Sending..." : "Submit"}
      </button>
    </form>
  );
}
```

### 3. Modal/Drawer with Event Listeners

```tsx
// islands/ui/Drawer.tsx
import { type ComponentChildren } from "preact";
import { useEffect } from "preact/hooks";
import { useId } from "../../sdk/hooks/useId.ts";

interface Props {
  children: ComponentChildren;
  aside: ComponentChildren;
  id?: string;
}

export default function Drawer({ children, aside, id = useId() }: Props) {
  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      if (e.key === "Escape") {
        const input = document.getElementById(id) as HTMLInputElement;
        if (input) input.checked = false;
      }
    };

    addEventListener("keydown", handler);
    
    return () => {
      removeEventListener("keydown", handler);
    };
  }, [id]);

  return (
    <div class="drawer">
      <input id={id} type="checkbox" class="drawer-toggle" />
      <div class="drawer-content">{children}</div>
      <aside class="drawer-side">
        <label for={id} class="drawer-overlay" />
        {aside}
      </aside>
    </div>
  );
}
```

## Best Practices for SSR + Islands

### ✅ Do

- **Use Islands for all client-side interactivity**
- **Process data server-side** with loaders and useDevice
- **Use Preact hooks** in Islands (useState, useEffect, useSignal)
- **Add cleanup functions** in useEffect
- **Use semantic HTML elements**
- **Implement proper accessibility** attributes
- **Keep Islands focused** and small
- **Use TypeScript** for type safety

### ❌ Don't

- **Don't use useScript** for new code (legacy pattern)
- **Don't put server-side hooks** (useDevice) inside Islands
- **Don't forget cleanup** in useEffect
- **Don't create large** monolithic Islands
- **Don't use event handlers** directly in SSR components
- **Don't mix client** and server concerns
- **Don't ignore accessibility** requirements

## Migration from useScript to Islands

### Before (Legacy useScript):
```tsx
import { useScript } from "@deco/deco/hooks";

function handleClick(id: string) {
  const btn = document.getElementById(id);
  btn?.classList.toggle("active");
}

export default function Button({ id }: Props) {
  return (
    <>
      <script
        dangerouslySetInnerHTML={{
          __html: useScript(handleClick, id),
        }}
      />
      <button 
        id={id}
        hx-on:click={`handleClick('${id}')`}
      >
        Click
      </button>
    </>
  );
}
```

### After (Modern Islands):
```tsx
// islands/ui/Button.tsx
import { useState } from "preact/hooks";

export default function Button() {
  const [isActive, setIsActive] = useState(false);

  return (
    <button 
      onClick={() => setIsActive(!isActive)}
      class={isActive ? "active" : ""}
    >
      Click
    </button>
  );
}
```

## When to Use What

### Use Server-Side (Sections):
- Data fetching with loaders
- Device detection (useDevice)
- Authentication checks
- SEO content
- Static content rendering
- Initial page state

### Use Islands:
- Forms with validation
- Interactive UI (modals, dropdowns, drawers)
- Client-side state management
- Event handlers (click, hover, scroll)
- Real-time updates
- Animations and transitions
- Third-party widget integration

## Performance Considerations

- **Islands are hydrated on the client**: Keep them small and focused
- **Minimize props passed to Islands**: Large props increase bundle size
- **Use signals for shared state**: Avoid prop drilling
- **Cleanup resources**: Always cleanup in useEffect returns
- **Lazy load heavy Islands**: Use dynamic imports if needed
- **Process data server-side**: Don't fetch data in Islands when you can use loaders
