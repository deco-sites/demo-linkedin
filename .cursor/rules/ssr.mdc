---
alwaysApply: false
description: This file describes SSR patterns, HTMX integration, and script injection in Deco Framework.
---

# SSR Patterns in Deco Framework

## Server-Side Rendering (SSR)

Deco Framework uses server-side rendering for all components. This means:

- All components are rendered on the server
- No client-side state management with hooks
- Use vanilla JS + HTMX for interactivity
- Scripts are injected using `useScript` utility

## Script Injection with useScript

The `useScript` utility allows you to inject vanilla JS functions into components:

```tsx
import { useScript } from "@deco/deco/hooks";

// Define your vanilla JS function
function myScript(name: string) {
  console.log("helloWorld", name);
}

// Use in component
export default function MyComponent() {
  return (
    <>
      {/* Inject script as module */}
      <script
        type="module"
        dangerouslySetInnerHTML={{
          __html: useScript(myScript, "lucas"),
        }}
      />

      {/* Use with HTMX events */}
      <Button hx-on:click={useScript(myScript, "Gabriel")} text="Click me" />
    </>
  );
}
```

### useScript Utility

The `useScript` utility is already implemented in Deco Framework and can be imported from:

```tsx
import { useScript } from "@deco/deco/hooks";
```

This utility allows you to inject vanilla JS functions into components for client-side interactivity.


## State Management in SSR

### Hidden Input State Control

Use hidden checkboxes or inputs to control component state:

```tsx
import { useScript } from "@deco/deco/hooks";
import { useId } from "../../sdk/useId.ts";

export default function ToggleButton({ text, id = `toggle-${useId()}` }: Props) {
  return (
    <>
      {/* Hidden checkbox for state */}
      <input type="checkbox" id={`${id}-state`} class="hidden" />

      {/* Script to handle toggle */}
      <script
        type="module"
        dangerouslySetInnerHTML={{
          __html: useScript(handleToggle, id),
        }}
      />

      <button
        id={id}
        hx-on:click={`handleToggle('${id}')`}
        class="btn"
      >
        {text}
      </button>
    </>
  );
}

function handleToggle(toggleId: string) {
  const checkbox = document.getElementById(`${toggleId}-state`) as HTMLInputElement;
  const button = document.getElementById(toggleId);

  if (checkbox && button) {
    checkbox.checked = !checkbox.checked;
    button.classList.toggle("active", checkbox.checked);
  }
}
```

### Data Attributes for State

```tsx
export default function Accordion({ title, content, id = `accordion-${useId()}` }: Props) {
  return (
    <>
      <script
        type="module"
        dangerouslySetInnerHTML={{
          __html: useScript(handleAccordion, id),
        }}
      />

      <div class="accordion">
        <button
          id={id}
          hx-on:click={`handleAccordion('${id}')`}
          class="accordion-header"
          data-expanded="false"
        >
          {title}
        </button>
        <div id={`${id}-content`} class="accordion-content hidden">
          {content}
        </div>
      </div>
    </>
  );
}

function handleAccordion(accordionId: string) {
  const button = document.getElementById(accordionId);
  const content = document.getElementById(`${accordionId}-content`);
  const isExpanded = button?.getAttribute("data-expanded") === "true";

  if (button && content) {
    button.setAttribute("data-expanded", (!isExpanded).toString());
    content.classList.toggle("hidden", isExpanded);
  }
}
```

## Common SSR Patterns

### Loading States with HTMX

```tsx
export default function DataLoader({ endpoint, id = `loader-${useId()}` }: Props) {
  return (
    <div id={id}>
      <button
        hx-get={endpoint}
        hx-target={`#${id}-content`}
        hx-swap="innerHTML"
        hx-indicator={`#${id}-loading`}
        class="btn-primary"
      >
        Load Data
      </button>
      
      <div id={`${id}-loading`} class="htmx-indicator">
        <div class="animate-pulse">Loading...</div>
      </div>
      
      <div id={`${id}-content`}></div>
    </div>
  );
}
```

## Best Practices for SSR

### ✅ Do

- Use `useScript` for client-side functionality
- Use HTMX for server interactions
- Control state with hidden inputs or data attributes
- Use unique IDs with `useId` utility
- Handle loading and error states with HTMX indicators
- Keep vanilla JS functions simple and focused
- Use semantic HTML elements
- Implement proper accessibility attributes

### ❌ Don't

- Use React/Preact hooks (useState, useEffect, useSignal, etc.)
- Try to manage complex client-side state
- Use event handlers directly in JSX (use HTMX instead)
- Forget to handle loading and error states
- Create deeply nested component hierarchies
- Ignore accessibility requirements
- Use external libraries for simple interactions

## HTMX Event Reference

### Common Events

- `hx-on:click` - Click events
- `hx-on:submit` - Form submission
- `hx-on:change` - Input changes
- `hx-on:blur` - Input blur
- `hx-on:focus` - Input focus
- `hx-on:load` - Page/component load

### HTMX Attributes

- `hx-get` - GET request
- `hx-post` - POST request
- `hx-put` - PUT request
- `hx-delete` - DELETE request
- `hx-target` - Target element for response
- `hx-swap` - How to swap content (innerHTML, outerHTML, etc.)
- `hx-trigger` - When to trigger (click, load, every 2s, etc.)
- `hx-indicator` - Loading indicator element
- `hx-confirm` - Confirmation dialog
- `hx-prompt` - Prompt for user input

### Swap Options

- `innerHTML` - Replace inner content
- `outerHTML` - Replace entire element
- `beforebegin` - Insert before element
- `afterbegin` - Insert at start of element
- `beforeend` - Insert at end of element
- `afterend` - Insert after element